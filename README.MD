## ğŸ›ï¸ Teste Mercado Livre

O enunciado do teste pede:

> â€œConstruir uma API backend simplificada que forneÃ§a detalhes de produtos para uso em uma funcionalidade de comparaÃ§Ã£o de itens. Sua implementaÃ§Ã£o deve seguir boas prÃ¡ticas estabelecidas de backend, fornecendo endpoints claros e eficientes para recuperar os dados necessÃ¡rios para comparaÃ§Ãµes de produtos.â€

Neste projeto, essa necessidade Ã© atendida pelos seguintes endpoints:

- `GET /v1/products/{id}` â€“ obtÃ©m os detalhes de um produto especÃ­fico, Ãºtil para buscar um item individual que o usuÃ¡rio adicionou Ã  comparaÃ§Ã£o.
- `GET /v1/products/batch` â€“ retorna detalhes de **vÃ¡rios produtos de uma vez**, a partir de uma lista de IDs.  
  Ã‰ o endpoint mais indicado para montar uma tabela de comparaÃ§Ã£o lado a lado no frontend.
- `GET /v1/products/page` â€“ permite **buscar e paginar produtos com filtros e ordenaÃ§Ã£o** (multi-sort).  
  Pode ser usado para a etapa em que o usuÃ¡rio estÃ¡ explorando/filtrando produtos antes de selecionar quais serÃ£o comparados.

Com essa combinaÃ§Ã£o, a API fornece tanto:
- os dados necessÃ¡rios para **descobrir** produtos (busca paginada), quanto
- os dados necessÃ¡rios para **comparar** produtos especÃ­ficos (busca em lote por IDs).

### ğŸ§± Tecnologias

- Kotlin 1.9.25
- Java 17
- Spring Boot 3.5.7

### Estrutura do Projeto

```cmd
â””â”€â”€src
    â””â”€â”€main
        â”œâ”€â”€â”€kotlin
        â”‚   â””â”€â”€â”€raulalvesre
        â”‚       â””â”€â”€â”€testemeli
        â”‚           â”‚
        â”‚           â”œâ”€â”€â”€application
        â”‚           â”‚   â””â”€â”€â”€usecase
        â”‚           â”‚
        â”‚           â”œâ”€â”€â”€domain
        â”‚           â”‚   â”œâ”€â”€â”€entity
        â”‚           â”‚   â”œâ”€â”€â”€enums
        â”‚           â”‚   â”œâ”€â”€â”€exception
        â”‚           â”‚   â”œâ”€â”€â”€pagination
        â”‚           â”‚   â”œâ”€â”€â”€search
        â”‚           â”‚   â”œâ”€â”€â”€repository
        â”‚           â”‚   â””â”€â”€â”€specification
        â”‚           â”‚
        â”‚           â””â”€â”€â”€infrastructure
        â”‚               â”œâ”€â”€â”€api
        â”‚               â”‚   â”œâ”€â”€â”€controller
        â”‚               â”‚   â”œâ”€â”€â”€exception
        â”‚               â”‚   â”œâ”€â”€â”€helper
        â”‚               â”‚   â”œâ”€â”€â”€mapper
        â”‚               â”‚   â”œâ”€â”€â”€request
        â”‚               â”‚   â””â”€â”€â”€response
        â”‚               â”‚
        â”‚               â””â”€â”€â”€persistence
        â”‚                   â”œâ”€â”€â”€config
        â”‚                   â””â”€â”€â”€repository
        â”‚
        â””â”€â”€â”€resources
            â”‚   application.properties
            â”‚
            â””â”€â”€â”€data
                    products.json
````

## Endpoints Principais

### ğŸ•µï¸ Buscar Produto
````text
GET /v1/products/{id}
````

Busca um produto pelo seu identificador Ãºnico.

### ParÃ¢metros de path

| Nome | Tipo | ObrigatÃ³rio | DescriÃ§Ã£o                       |
|------|------|-------------|---------------------------------|
| `id` | Long | sim         | ID do produto a ser consultado. |

### Respostas

| CÃ³digo | DescriÃ§Ã£o                                |
|--------|------------------------------------------|
| `200`  | Produto encontrado com sucesso.          |
| `404`  | Nenhum produto encontrado com esse ID.   |

### ğŸ¯ Buscar Produtos EspecÃ­ficos

````text
GET /v1/products/batch
````

Retorna uma lista com produtos solicitados de produtos.

**Uso para ComparaÃ§Ã£o:**

Este endpoint Ã© ideal para recuperar mÃºltiplos produtos para comparaÃ§Ã£o lado a lado.
Use para construir tabelas de comparaÃ§Ã£o na interface do usuÃ¡rio.


### ParÃ¢metros de query

| Nome  | Tipo       | ObrigatÃ³rio | DescriÃ§Ã£o                       |
|-------|------------|-------------|---------------------------------|
| `ids` | List<Long> | sim         | ID do produto a ser consultado. |

### Regras:

#### Limite de 50 IDs por requisiÃ§Ã£o

- Esse endpoint aceita no mÃ¡ximo 50 IDs em uma Ãºnica chamada.
- Esse limite existe por alguns motivos:
  - **Performance e latÃªncia:** buscar muitos registros de uma vez aumenta o tempo de resposta da API e pode degradar a experiÃªncia do usuÃ¡rio.
  - **Uso eficiente de recursos:** requisiÃ§Ãµes com listas muito grandes pressionam o banco de dados (CPU, memÃ³ria, I/O) e podem impactar outras operaÃ§Ãµes do sistema.
  - **ProteÃ§Ã£o contra abusos:** o limite ajuda a evitar chamadas acidentais ou mal-formadas com listas enormes de IDs, que poderiam causar lentidÃ£o ou indisponibilidade.
  - **Simplicidade de uso:** 50 itens Ã© um tamanho suficiente para a maioria dos cenÃ¡rios de consulta em lote. Casos que precisem de mais dados podem ser tratados com paginaÃ§Ã£o ou mÃºltiplas chamadas Ã  API.

Caso seja necessÃ¡rio consultar mais de 50 produtos, o cliente deve dividir a lista em lotes de atÃ© 50 IDs e chamar o mÃ©todo mÃºltiplas vezes.

**Exemplo:**

```text
GET /v1/products/batch?ids=1,ids=2
````

### ğŸ¯ Buscar PÃ¡gina de  Produtos

````text
GET /v1/products/page
````

Retorna uma lista paginada de produtos filtrados e ordenados de acordo com os parÃ¢metros de consulta.

### ParÃ¢metros de query

#### Filtros

| Nome              | Tipo                | ObrigatÃ³rio | DescriÃ§Ã£o                                                                         |
|-------------------|---------------------|-------------|-----------------------------------------------------------------------------------|
| `name`            | String              | nÃ£o         | Filtra produtos cujo **nome contenha** o texto informado (case-insensitive).      |
| `category`        | String              | nÃ£o         | Filtra produtos cujo **categoria contenha** o texto informado (case-insensitive). |
| `brand`           | String              | nÃ£o         | Filtra produtos cujo **marca contenha** o texto informado (case-insensitive).     |
| `condition`       | String              | nÃ£o         | Filtra pela condiÃ§Ã£o do produto (ex.: `NEW`, `USED`).                             |
| `minPrice`        | BigDecimal          | nÃ£o         | PreÃ§o mÃ­nimo (inclusivo).                                                         |
| `maxPrice`        | BigDecimal          | nÃ£o         | PreÃ§o mÃ¡ximo (inclusivo).                                                         |
| `minRating`       | Long                | nÃ£o         | Nota mÃ­nima (inclusivo).                                                          |
| `maxRating`       | Long                | nÃ£o         | Nota mÃ¡xima (inclusivo).                                                          |
| `hasFreeShipping` | Boolean             | nÃ£o         | Se `true`, retorna apenas produtos com frete grÃ¡tis.                              |
| `isAvailable`     | Boolean             | nÃ£o         | Se `true`, retorna apenas produtos disponÃ­veis.                                   |
| `specifications`	 | Map<String, String> | 	nÃ£o        | Filtra por especificaÃ§Ãµes do produto usando contains case-insensitive.            |

Todos os filtros sÃ£o opcionais. Quando um parÃ¢metro nÃ£o Ã© enviado, ele simplesmente nÃ£o Ã© considerado no filtro.

#### PaginaÃ§Ã£o

| Nome   | Tipo | ObrigatÃ³rio | PadrÃ£o | DescriÃ§Ã£o                                |
|--------|------|-------------|--------|------------------------------------------|
| `page` | Int  | nÃ£o         | `0`    | Ãndice da pÃ¡gina (**baseado em zero**).  |
| `size` | Int  | nÃ£o         | `10`   | Quantidade de itens por pÃ¡gina.          |

#### OrdenaÃ§Ã£o

A ordenaÃ§Ã£o Ã© feita usando dois arrays paralelos:

| Nome        | Tipo          | ObrigatÃ³rio | DescriÃ§Ã£o                                                                 |
|-------------|---------------|-------------|---------------------------------------------------------------------------|
| `sortBy`    | List\<String> | nÃ£o         | Lista de campos para ordenaÃ§Ã£o, em ordem de prioridade (ex.: `NAME`, `PRICE`, `RATING`, `BRAND`). |
| `direction` | List\<String> | nÃ£o         | DireÃ§Ã£o da ordenaÃ§Ã£o para cada campo (`ASC` ou `DESC`), casada **por Ã­ndice** com `sortBy`. |

### Regras:

- Caso`sortBy` tenha mais elementos do que `direction`, os campos excedentes em sortBy serÃ£o ordenados com direÃ§Ã£o padrÃ£o ASC.
- Limite de atÃ© 50 produtos por requisiÃ§Ã£o, pelos mesmos motivos jÃ¡ descritos para o endpoint de busca em batch.

**Exemplo:**

```text
GET /v1/products/page?name=iphone&minPrice=2000&sortBy=PRICE&sortBy=RATING&direction=DESC&direction=ASC
````

Buscar smartphones com caracterÃ­sticas especÃ­ficas
```text
GET /v1/products/page?specifications[storage]=128GB&specifications[color]=black&specifications[5G]=true
```

Esse request vai:

- Filtrar produtos cujo nome contenha "iphone";
- Filtrar produtos com preÃ§o â‰¥ 2000;
- Ordenar primeiro por PRICE em ordem decrescente;
- Usar RATING em ordem crescente como critÃ©rio de desempate.

## DocumentaÃ§Ã£o Swagger

A documentaÃ§Ã£o dos endpoints pode ser acessada em:

http://localhost:8080/swagger-ui/index.html

## ğŸ¤” DecisÃµes de projeto

### Arquitetura

O projeto segue uma arquitetura em camadas inspirada em Clean Architecture / DDD, mas aplicada de forma pragmÃ¡tica, sem purismo. Tomei essa decisÃ£o priorizando clareza, simplicidade e velocidade de desenvolvimento.

A organizaÃ§Ã£o das camadas busca deixar explÃ­cito:

- `domain` â€“ onde vivem as regras de negÃ³cio e o modelo de domÃ­nio;
- `application` â€“ onde estÃ£o os casos de uso e a orquestraÃ§Ã£o do fluxo da aplicaÃ§Ã£o;
- `infrastructure` â€“ onde lidamos com frameworks, detalhes tÃ©cnicos e integraÃ§Ãµes externas.

### PersistÃªncia

- **Sem banco de dados**  
  Os produtos sÃ£o carregados a partir do `src/main/resources/data/products.json` durante a inicializaÃ§Ã£o da aplicaÃ§Ã£o.

Essa abordagem simplifica o setup (basta subir a aplicaÃ§Ã£o) e mantÃ©m o foco nas regras de negÃ³cio, sem a complexidade extra de configurar um banco de dados.


### Filtros de busca

Os filtros de busca foram implementados usando o **Specification Pattern**.

- Cada critÃ©rio de filtro (nome, categoria, marca, condiÃ§Ã£o, faixa de preÃ§o, rating, frete grÃ¡tis, disponibilidade, etc.) Ã© representado por uma implementaÃ§Ã£o de `Specification<Product>`  
  (por exemplo: `NameSpecification`, `CategorySpecification`, `PriceRangeSpecification`).
- A funÃ§Ã£o `ProductFilter.toSpecification()` compÃµe essas specifications em cadeia usando `.and(...)`, gerando uma Ãºnica specification final a partir dos parÃ¢metros informados.
- Quando algum campo do `ProductFilter` Ã© nulo, a specification correspondente se comporta como â€œneutraâ€ (nÃ£o restringe o resultado), permitindo montar o filtro dinamicamente sem `ifs` espalhados.

### OrdenaÃ§Ã£o

- **Multi-sort inspirado no DBeaver e Grafana**  
  A ordenaÃ§Ã£o da lista de produtos suporta **mÃºltiplos campos**:
    - A API recebe arrays `sortBy` e `direction`.
    - Cada posiÃ§Ã£o de `sortBy` corresponde Ã  mesma posiÃ§Ã£o em `direction`.
    - Quando hÃ¡ mais campos em `sortBy` do que em `direction`, os campos excedentes usam direÃ§Ã£o padrÃ£o `ASC`.

A ideia veio da experiÃªncia com ferramentas como o **DBeaver** e **Grafana**, que permitem definir multi-sort na UI, e quis reproduzir esse comportamento no backend como um exercÃ­cio de implementaÃ§Ã£o.

### Testes unitÃ¡rios

A aplicaÃ§Ã£o nÃ£o possui **100% de cobertura**, por escolha. Preferi focar nos pontos mais relevantes do fluxo principal de busca de produtos.

Atualmente, existem testes cobrindo principalmente:

- `ProductService`
    - OrquestraÃ§Ã£o do fluxo de busca de produtos.
    - Chamada do repositÃ³rio com os parÃ¢metros corretos.

- `JsonProductRepository`
    - AplicaÃ§Ã£o dos filtros de busca.
    - LÃ³gica de ordenaÃ§Ã£o, incluindo **multi-sort**.

- `Specifications de filtro** (domain.specification)`
    - Cada critÃ©rio de filtro individual (nome, categoria, faixa de preÃ§o, rating, frete grÃ¡tis, etc.).
    - ComposiÃ§Ã£o das specifications para montar o filtro final.

A ideia foi garantir uma boa cobertura do **fluxo principal de consulta**, que Ã© o foco do desafio, em vez de buscar 100% de cobertura em cÃ³digo perifÃ©rico.

## ğŸ‘·ğŸ»â€â™‚ï¸ Como rodar o projeto

### PrÃ©-requisitos

- **Java 17+**

### Passos

```bash
```bash
# Clonar o repositÃ³rio
git clone <URL_DO_REPOSITORIO>
cd testemeli

# Rodar a aplicaÃ§Ã£o na porta que preferir, no caso estaremos utilizando a 8080
./gradlew bootRun --args='--server.port=8080'
````
ApÃ³s subir, a API estarÃ¡ disponÃ­vel em `http://localhost:8080`.

Recomendo utilizar o swagger para explorar e interagir com a API:
http://localhost:8080/swagger-ui/index.html


### ğŸ¤– Prompts Utilizados

Durante o desenvolvimento deste projeto, utilizei IA (ChatGPT) como ferramenta de apoio para discutir decisÃµes de arquitetura, performance e testes. Abaixo alguns dos principais prompts utilizados:

- **Estrutura de pacotes / arquitetura**
    - *"Me ajude a criar uma estrutura de pacotes que siga princÃ­pios de DDD e Clean Architecture para este projeto."*
- **GeraÃ§Ã£o de dados de mock**
    - *"Crie um JSON de produtos seguindo esta data class \***dto de Product\***
- **RefatoraÃ§Ã£o de filtros com Specification Pattern**
    - *"Tenho um `if` gigantesco aplicando vÃ¡rios filtros em uma lista de produtos. Consigo usar o design pattern de Specification para deixar esse cÃ³digo mais limpo e flexÃ­vel? Como ficaria a estrutura das Specifications e a composiÃ§Ã£o entre elas nesse caso?"*
- **Apoio em testes unitÃ¡rios (Specifications)**
    - *"Me ajude a escrever os testes das Specifications: quais seriam bons cenÃ¡rios para testar esta Specification: \***cÃ³digo da specification\*** ?"*

